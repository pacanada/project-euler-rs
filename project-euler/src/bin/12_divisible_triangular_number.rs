// <p>The sequence of triangle numbers is generated by adding the natural numbers. So the $7$<sup>th</sup> triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$. The first ten terms would be:
// $$1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \dots$$</p>
// <p>Let us list the factors of the first seven triangle numbers:</p>
// \begin{align}
// \mathbf 1 &amp;\colon 1\\
// \mathbf 3 &amp;\colon 1,3\\
// \mathbf 6 &amp;\colon 1,2,3,6\\
// \mathbf{10} &amp;\colon 1,2,5,10\\
// \mathbf{15} &amp;\colon 1,3,5,15\\
// \mathbf{21} &amp;\colon 1,3,7,21\\
// \mathbf{28} &amp;\colon 1,2,4,7,14,28
// \end{align}
// <p>We can see that $28$ is the first triangle number to have over five divisors.</p>
// <p>What is the value of the first triangle number to have over five hundred divisors?</p>


use project_euler::utils;


fn approach_1(target_number_divisors: u32) -> u32 {
    fn nth_triangular_number(n: u32)->u32 {
        n*(n+1)/2

    }
    fn get_number_of_divisors(number: u32) -> u32 {
        // we can consider a number like 10, with prime factors: 2,5. The possible arrangement with different set sizes are 2^length
        // for numbers with duplicated prime factors like 12: 2,2,3 -> 1,2,3,4,6,12
        let prime_factors = utils::get_factors(number).unwrap();
        // get the ocurrence count per number
        let count_map = utils::convert_to_count_map(prime_factors);
        // compute the number of possible arrangements of prime factors: prod_{i=1}^{n} = k_i +1 (being k_i the number of ocurrences)
        let number_of_divisors = count_map.iter().fold(1, |acc, (_,v)| acc*(v+1));
        number_of_divisors
    }
    let mut nth_candidate = 2;
   
    loop {
        
        let triangular_number = nth_triangular_number(nth_candidate);
        let n_divisors = get_number_of_divisors(triangular_number);
        if nth_candidate%1000==0{
           println!("Checking for triangular number in position {nth_candidate}: {triangular_number}. Number of divisors: {n_divisors}");

        }
        if n_divisors >= target_number_divisors {return  triangular_number;}
        nth_candidate+=1;

    }
}

fn main() {
    let n_divisors = 500;
    let sol = approach_1(n_divisors);

    println!("The first triangle number with {n_divisors} divisors is {sol}");
}
