// <p>The sequence of triangle numbers is generated by adding the natural numbers. So the $7$<sup>th</sup> triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$. The first ten terms would be:
// $$1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \dots$$</p>
// <p>Let us list the factors of the first seven triangle numbers:</p>
// \begin{align}
// \mathbf 1 &amp;\colon 1\\
// \mathbf 3 &amp;\colon 1,3\\
// \mathbf 6 &amp;\colon 1,2,3,6\\
// \mathbf{10} &amp;\colon 1,2,5,10\\
// \mathbf{15} &amp;\colon 1,3,5,15\\
// \mathbf{21} &amp;\colon 1,3,7,21\\
// \mathbf{28} &amp;\colon 1,2,4,7,14,28
// \end{align}
// <p>We can see that $28$ is the first triangle number to have over five divisors.</p>
// <p>What is the value of the first triangle number to have over five hundred divisors?</p>

use project_euler::utils;


fn approach_1(target_number_divisors: u32) -> u32 {
    fn nth_triangular_number(n: u32)->u32 {
        n*(n+1)/2

    }
    fn get_number_of_divisors(number: u32) -> u32 {
        // we can consider a number like 10, with prime factors: 2,5. The possible arrangement with different set sizes are 2^length
        // for numbers with duplicated prime factors like 12: 2,2,3 -> 1,2,3,4,6,12 -> 2^3-2^(d-1)
    //     let mut number_of_divisors = 2;
    //     for i in 2..number/2+ 1 {
    //         if number % i == 0 {
    //             number_of_divisors+=1;
    //         }

    //     }
    //     number_of_divisors
    // }

    // let mut nth_candidate = 1;
   
   
    loop {
        
        let triangular_number = nth_triangular_number(nth_candidate);
        let n_divisors = get_number_of_divisors(triangular_number);
        //println!("Checking for {nth_candidate}: {triangular_number}. Number of divisors: {n_divisors}");
        if nth_candidate%1000==0{
            println!("Checking for {nth_candidate}: {triangular_number}. Number of divisors: {n_divisors}");

        }
        if n_divisors == target_number_divisors {return  triangular_number;}
        nth_candidate+=1;

    }
}

fn main() {
    let n_divisors = 500;
    println!("{:?}", utils::get_factors(56))
    //let sol = approach_1(n_divisors);
    // prime factors (1),2,5, 1 can be ignored, but how do we treat repeated factors?
    //
    // 1
    // 2
    // 5
    // 1,2
    // 1,5
    // 2,5
    // 1,2,5

    // is it 2^prime factor-2^number of repeated factors?

    //println!("The first triangle number with {n_divisors} divisors is {sol}");
}
